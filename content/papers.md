+++
title = "Research"
layout = "papers"
+++

I am interested in the implementation of, and design of abstractions for,
highly concurrent and distributed systems.

Systems software is judged by whether it presents an _efficient, explainable,
and reliable_ view of the layers underneath it to the levels above. Any
high-level developer will struggle to produce correct and efficient application
software should their systems programmer compatriots fail to build the
foundation of the software stack well.  However, as hardware becomes more
parallel, more heterogenous, and more opaque, the "efficient and explainable"
veneer has stretched increasingly thin to at the very most retain "reliable".
In an era of distributed shared memory, nonvolatile main memory, and
hot-swappable coprocessing units, systems software can no longer get away with
idealized abstractions of half century-old hardware.  Even with an optimal
up-front system design for today's modern hardware, it remains an ever-moving
target.

In short: Systems software must adapt architecturally for current hardware
developments, and support enough flexibility to adjust to future ones.  I
believe that the path out of the "efficient, explainable, reliable: pick two"
tarpit necessitates adopting formalisms and mechanized proof techniques from
the formal methods and programming languages community.

Here's some of the research I've published.

